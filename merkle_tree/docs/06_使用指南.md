# PyGit 使用指南

## 快速开始

PyGit是一个基于Merkle Tree原理实现的简化版Git版本控制系统，用于学习和研究Merkle Tree在版本控制中的应用。

## 安装和设置

### 环境要求
- Python 3.8+
- 无需额外依赖（使用Python标准库）

### 项目结构
```
merkle_tree/
├── src/                     # 源代码
│   ├── core/               # 核心功能
│   └── objects/            # 对象模型
├── docs/                    # 文档
├── tests/                   # 测试
└── examples/               # 示例
```

## 基本使用

### 1. 初始化仓库

```python
import sys
sys.path.insert(0, 'src')
from core.repository import ObjectDatabase
from core.index import Index
from core.merkle import MerkleTree

# 创建仓库组件
repo_path = '/path/to/your/repo'
odb = ObjectDatabase(repo_path)
index = Index(repo_path)
merkle_tree = MerkleTree(repo_path)
```

### 2. 添加文件到暂存区

```python
# 添加单个文件
index.add_file('readme.txt', '100644')

# 添加多个文件
files = ['main.py', 'utils.py', 'config.json']
for file in files:
    index.add_file(file, '100644')

# 查看暂存区状态
staged_files = index.get_staged_files()
print(f"暂存的文件: {staged_files}")
```

### 3. 构建Merkle Tree

```python
# 从工作目录构建Tree
tree = merkle_tree.build_tree_from_directory('.')

# 或者从文件列表构建
files_dict = {
    'src/main.py': 'print("Hello World")',
    'src/utils.py': 'def helper(): pass',
    'README.md': '# Project'
}
tree = merkle_tree.build_tree_from_files(files_dict)

# 查看Tree结构
print(f"Tree哈希: {tree.hash}")
print(f"包含文件: {merkle_tree.list_files(tree)}")
```

### 4. 创建提交

```python
from objects.commit import Commit
from datetime import datetime

# 创建初始提交
commit = Commit(
    tree_hash=tree.hash,
    author="Your Name <your@email.com>",
    committer="Your Name <your@email.com>",
    message="Initial commit",
    timestamp=datetime.now()
)

# 存储对象到数据库
odb.store_object(tree)
odb.store_object(commit)

print(f"提交创建成功: {commit.hash}")
```

### 5. 查看历史

```python
# 获取提交信息
print(f"Tree哈希: {commit.tree_hash}")
print(f"父提交: {commit.parent_hash}")
print(f"作者: {commit.author}")
print(f"提交消息: {commit.message}")

# 创建第二个提交
commit2 = Commit(
    tree_hash=tree.hash,  # 假设Tree有变化
    parent_hash=commit.hash,
    author="Your Name <your@email.com>",
    message="Add new features",
    timestamp=datetime.now()
)
```

## 高级功能

### 1. 文件状态检查

```python
# 检查文件是否被修改
is_modified = index.is_file_modified('main.py')
print(f"文件是否修改: {is_modified}")

# 获取所有修改的文件
modified_files = index.get_modified_files()
print(f"修改的文件: {modified_files}")

# 获取未跟踪的文件
untracked_files = index.get_untracked_files()
print(f"未跟踪的文件: {untracked_files}")
```

### 2. Tree比较

```python
# 构建两个不同的Tree
tree1 = merkle_tree.build_tree_from_directory('version1')
tree2 = merkle_tree.build_tree_from_directory('version2')

# 比较差异
differences = merkle_tree.compare_trees(tree1, tree2)
print(f"新增文件: {differences['added']}")
print(f"删除文件: {differences['removed']}")
print(f"修改文件: {differences['modified']}")

# 查找变更的文件
changed_files = merkle_tree.find_changed_files(tree1, tree2)
print(f"变更文件: {changed_files}")
```

### 3. 对象数据库操作

```python
# 存储对象
blob = Blob('File content')
blob_hash = odb.store_object(blob)

# 获取对象
retrieved_blob = odb.get_object(blob_hash)

# 检查对象是否存在
exists = odb.object_exists(blob_hash)

# 列出所有对象
all_objects = odb.list_objects()
print(f"总对象数: {len(all_objects)}")

# 按类型列出对象
blob_objects = odb.list_objects('blob')
tree_objects = odb.list_objects('tree')
commit_objects = odb.list_objects('commit')
```

### 4. 统计和验证

```python
# 获取索引统计
index_stats = index.get_stats()
print(f"索引统计: {index_stats}")

# 验证索引完整性
index_validation = index.validate()
print(f"索引验证: {index_validation}")

# 获取对象数据库统计
odb_stats = odb.get_stats()
print(f"对象数据库统计: {odb_stats}")

# 验证对象完整性
odb_integrity = odb.verify_integrity()
print(f"完整性验证: {odb_integrity}")

# 验证Tree完整性
tree_integrity = merkle_tree.validate_tree_integrity(tree)
print(f"Tree完整性: {tree_integrity}")
```

## 完整示例

### 示例1：基本工作流程

```python
import sys
import os
import shutil
import tempfile
from datetime import datetime

sys.path.insert(0, 'src')
from core.repository import ObjectDatabase
from core.index import Index
from core.merkle import MerkleTree
from objects.commit import Commit

# 创建临时工作目录
work_dir = tempfile.mkdtemp()
print(f"工作目录: {work_dir}")

try:
    # 初始化仓库
    odb = ObjectDatabase(work_dir)
    index = Index(work_dir)
    merkle_tree = MerkleTree(work_dir)
    
    # 创建一些文件
    os.makedirs(os.path.join(work_dir, 'src'))
    
    with open(os.path.join(work_dir, 'README.md'), 'w') as f:
        f.write('# My Project\\nThis is a test project.')
    
    with open(os.path.join(work_dir, 'src', 'main.py'), 'w') as f:
        f.write('print("Hello, World!")')
    
    # 添加文件到暂存区
    index.add_file('README.md', '100644')
    index.add_file('src/main.py', '100644')
    
    # 构建Tree
    tree = merkle_tree.build_tree_from_directory(work_dir)
    
    # 创建提交
    commit = Commit(
        tree_hash=tree.hash,
        author="Test User <test@example.com>",
        message="Initial commit",
        timestamp=datetime.now()
    )
    
    # 存储对象
    odb.store_object(tree)
    odb.store_object(commit)
    
    print(f"初始提交: {commit.hash}")
    print(f"Tree: {tree.hash}")
    print(f"文件列表: {merkle_tree.list_files(tree)}")
    
    # 修改文件
    with open(os.path.join(work_dir, 'src', 'main.py'), 'w') as f:
        f.write('print("Hello, Merkle Tree!")\\nprint("This is updated.")')
    
    # 更新暂存区
    index.update_entry('src/main.py')
    
    # 重新构建Tree
    tree2 = merkle_tree.build_tree_from_directory(work_dir)
    
    # 创建第二个提交
    commit2 = Commit(
        tree_hash=tree2.hash,
        parent_hash=commit.hash,
        author="Test User <test@example.com>",
        message="Update main.py",
        timestamp=datetime.now()
    )
    
    odb.store_object(tree2)
    odb.store_object(commit2)
    
    print(f"第二个提交: {commit2.hash}")
    
    # 比较两个版本
    differences = merkle_tree.compare_trees(tree, tree2)
    print(f"版本差异: {differences}")
    
finally:
    # 清理
    shutil.rmtree(work_dir)
```

### 示例2：Merkle Tree演示

```python
import sys
sys.path.insert(0, 'src')
from core.merkle import MerkleTree
from objects.commit import Commit
from datetime import datetime

# 创建MerkleTree管理器
merkle_tree = MerkleTree('/path/to/project')

# 定义文件内容
project_files = {
    'src/main.py': '''
def main():
    print("Hello, Merkle Tree!")

if __name__ == "__main__":
    main()
''',
    'src/utils.py': '''
def helper():
    return "Helper function"

def calculate_hash(data):
    import hashlib
    return hashlib.sha1(data.encode()).hexdigest()
''',
    'README.md': '# Merkle Tree Project\\n\\nThis project demonstrates Merkle Tree in version control.',
    'config.json': '{"name": "merkle-tree-demo", "version": "1.0.0"}'
}

# 构建Tree
tree = merkle_tree.build_tree_from_files(project_files)

# 获取统计信息
stats = merkle_tree.get_tree_statistics(tree)
print(f"项目统计:")
print(f"  文件数: {stats['total_files']}")
print(f"  目录数: {stats['total_directories']}")
print(f"  估计大小: {stats['total_size']} bytes")

# 验证完整性
is_valid = merkle_tree.validate_tree_integrity(tree)
print(f"Tree完整性: {'✓' if is_valid else '✗'}")

# 创建提交
commit = merkle_tree.create_commit(tree, "Initial project structure")
print(f"提交哈希: {commit.hash}")

# 模拟文件修改
modified_files = project_files.copy()
modified_files['src/main.py'] = '''
def main():
    print("Hello, Updated Merkle Tree!")
    print("This file has been modified.")

if __name__ == "__main__":
    main()
'''

# 构建修改后的Tree
tree2 = merkle_tree.build_tree_from_files(modified_files)

# 比较差异
differences = merkle_tree.compare_trees(tree, tree2)
print(f"\\n变更检测:")
print(f"  新增文件: {differences['added']}")
print(f"  删除文件: {differences['removed']}")
print(f"  修改文件: {differences['modified']}")

# 创建版本历史
commit2 = merkle_tree.create_commit(tree2, "Update main.py", commit)
print(f"\\n版本历史:")
print(f"  初始提交: {commit.hash[:8]}...")
print(f"  第二次提交: {commit2.hash[:8]}...")
print(f"  父提交: {commit2.parent_hash[:8]}...")
```

## 最佳实践

### 1. 文件管理
- 定期清理无用对象
- 监控存储空间使用
- 验证数据完整性

### 2. 性能优化
- 批量操作优于单条操作
- 合理使用索引缓存
- 避免频繁的Tree重建

### 3. 错误处理
- 始终检查文件是否存在
- 处理对象存储失败情况
- 验证数据完整性

## 故障排除

### 常见问题

1. **导入错误**: 确保正确设置Python路径
2. **文件权限**: 确保有读写权限
3. **磁盘空间**: 监控存储空间使用
4. **内存使用**: 大文件注意内存管理

### 调试技巧

1. 使用统计信息监控状态
2. 定期验证数据完整性
3. 查看详细错误信息
4. 使用临时目录进行测试

这个使用指南提供了PyGit的完整使用方法，从基本操作到高级功能，帮助你理解和使用基于Merkle Tree的版本控制系统。